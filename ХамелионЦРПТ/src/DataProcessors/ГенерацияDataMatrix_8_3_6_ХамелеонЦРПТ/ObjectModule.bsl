
Перем ПараметрыКода;

Функция Сгенерировать(Знач ИсходнаяСтрока) Экспорт
	
	Если РегистрыСведений.НастройкиПрограммы_ХамелеонЦРПТ.Получить().ДобавитьПрефиксДляGS1 Тогда
//		ИсходнаяСтрока=Символ(232)+ИсходнаяСтрока;
//		ИсходнаяСтрока=РаскодироватьСтроку("%1D",СпособКодированияСтроки.КодировкаURL)+ИсходнаяСтрока;
//		//ИсходнаяСтрока=РаскодироватьСтроку("%E8",СпособКодированияСтроки.КодировкаURL)+ИсходнаяСтрока;
	КонецЕсли;
	КодыСимволов = ЗакодироватьДанные(ИсходнаяСтрока);
	БайтыСимволов = ДобавитьСлужебнуюИнформацию(КодыСимволов);
	Блоки = РазделитьИнформациюНаБлоки(БайтыСимволов);
	БайтыКоррекции = СоздатьБайтыКоррекции(Блоки);
	БайтыДанных = ОбъединитьБлоки(Блоки, БайтыКоррекции);
	Холст = РазместитьИнформацию(БайтыДанных);
	Возврат СоздатьКартинку(Холст);
		
КонецФункции

#Область Высокоуровневое_кодирование

Функция ЗакодироватьДанные(Знач ИсходнаяСтрока)
	
	Результат = Новый Массив;
	КодЦифры0 = 48;
	КодЦифры9 = 57;              
	НомСимв = 1;
	
	
	Пока НомСимв <= СтрДлина(ИсходнаяСтрока) Цикл
		
		КодТекСимв = КодСимвола(ИсходнаяСтрока, НомСимв);
		КодСледСимв = КодСимвола(ИсходнаяСтрока, НомСимв + 1);
		
		Если (КодТекСимв >= КодЦифры0 И КодТекСимв <= КодЦифры9) И (КодСледСимв >= КодЦифры0 И КодСледСимв <= КодЦифры9) Тогда
			Результат.Добавить(Число(Сред(ИсходнаяСтрока, НомСимв, 2)) + 130);
			НомСимв = НомСимв + 1;
		ИначеЕсли КодТекСимв >= 128 Тогда
			Результат.Добавить(235);
			Результат.Добавить(КодТекСимв - 127);
		Иначе
			Результат.Добавить(КодТекСимв + 1);
		КонецЕсли;
		
		НомСимв = НомСимв + 1;
		
	КонецЦикла;
	
	Если РегистрыСведений.НастройкиПрограммы_ХамелеонЦРПТ.Получить().ДобавитьПрефиксДляGS1 Тогда
		Результат.Вставить(0, 232);
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

Функция ДобавитьСлужебнуюИнформацию(Знач КодыСимволов)
	
	Для каждого Стр Из ТаблицаЗависимостей() Цикл
		Если КодыСимволов.Количество() <= Стр.КодовДанных Тогда
			ПараметрыКода = Стр;
			Прервать;
		КонецЕсли;
	КонецЦикла;
	
	Если ПараметрыКода.КодовДанных = КодыСимволов.Количество() Тогда
		Возврат КодыСимволов;
	КонецЕсли;
	
	КодыСимволов.Добавить(129);
	
	Для Сч = 1 По ПараметрыКода.КодовДанных - КодыСимволов.Количество() Цикл
		ПСЧ = ((149 * Сч) % 253) + 1;
		КодыСимволов.Добавить((ПСЧ + 129) % 254);
	КонецЦикла;
	
	Возврат КодыСимволов;
	
КонецФункции

Функция РазделитьИнформациюНаБлоки(БайтыСимволов)
	
	Блоки = Новый Массив;
	Если ПараметрыКода.ВсегоБлоков = 1 Тогда
		Блоки.Добавить(БайтыСимволов);
		Возврат Блоки;
	КонецЕсли;
	
	Для Сч = 1 По ПараметрыКода.ВсегоБлоков Цикл
		Блоки.Добавить(Новый Массив);
	КонецЦикла;
	
	ИндБайта = 0;
	Пока ИндБайта < ПараметрыКода.КодовДанных Цикл
		Для ИндБлока = 0 По ПараметрыКода.ВсегоБлоков - 1 Цикл
			Блоки[ИндБлока].Добавить(БайтыСимволов[ИндБайта]);
			ИндБайта = ИндБайта + 1;
		КонецЦикла;
	КонецЦикла;
	
	Возврат Блоки;
	
КонецФункции

Функция СоздатьБайтыКоррекции(Блоки)
	
	ПобитИсклИли = ЗначениеИзСтрокиВнутр(ПолучитьМакет("ПобитовоеИсключающееИли").ПолучитьТекст());
	ВсегоБайтовКоррекции = ПараметрыКода.КодовКоррекции / ПараметрыКода.ВсегоБлоков;
	ГенМногочлен = ГенерирующийМногочлен(ВсегоБайтовКоррекции);
	ОбаПоляГалуа = ПоляГалуа();
	ПолеГалуа = ОбаПоляГалуа.ПрямоеПоле;
	ОбратноеПолеГалуа = ОбаПоляГалуа.ОбратноеПоле;
	Результат = Новый Массив;
	
	Для каждого Блок Из Блоки Цикл
		
		БайтыКоррекции = Новый Массив;
		Для каждого Байт Из Блок Цикл
			БайтыКоррекции.Добавить(Байт);
		КонецЦикла;
		Для Сч = 1 По ВсегоБайтовКоррекции - Блок.Количество() Цикл
			БайтыКоррекции.Добавить(0);
		КонецЦикла;
		
		Для Сч = 1 По Блок.Количество() Цикл
			
			ТекБайт = БайтыКоррекции[0];
			БайтыКоррекции.Удалить(0);
			БайтыКоррекции.Добавить(0);
			
			Если ТекБайт = 0 Тогда
				Продолжить;
			КонецЕсли;
			
			ТекБайт = ОбратноеПолеГалуа.Получить(ТекБайт);    
			
			Для Инд = 0 По ГенМногочлен.ВГраница() Цикл
				ТекЧлен = ОбратноеПолеГалуа.Получить(ГенМногочлен[Инд]);
				ТекЧлен = (ТекЧлен + ТекБайт) % 255;
				ТекЧлен = ПолеГалуа.Получить(ТекЧлен);				
				Слагаемые = "" + Мин(БайтыКоррекции[Инд], ТекЧлен) + "+" + Макс(БайтыКоррекции[Инд], ТекЧлен);
				БайтыКоррекции[Инд] = Число(ПобитИсклИли[Слагаемые]);
			КонецЦикла;
			
		КонецЦикла;
		
		Результат.Добавить(БайтыКоррекции);
		
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

Функция ОбъединитьБлоки(БайтыСимволов, БайтыКоррекции)
	
	Результат = Новый Массив;
	Из10в2 = ПереводИз10в2();
	Для Инд = 0 По ПараметрыКода.ВсегоБлоков - 1 Цикл
		Для каждого Байт Из БайтыСимволов[Инд] Цикл
			Результат.Добавить(Из10в2[Байт]);	
		КонецЦикла; 	
		Для каждого Байт Из БайтыКоррекции[Инд] Цикл
			Результат.Добавить(Из10в2[Байт]);
		КонецЦикла;
	КонецЦикла;
	Возврат Результат
	
КонецФункции

Функция ТаблицаЗависимостей()
	
	Текст = ПолучитьМакет("РазмерыКодов");
	
	Результат = Новый ТаблицаЗначений;
	Для каждого ИмяКол Из СтрРазделить_1(Текст.ПолучитьСтроку(1), Символы.Таб) Цикл
		Результат.Колонки.Добавить(ИмяКол);
	КонецЦикла;
	
	Для НомСтр = 2 По Текст.КоличествоСтрок() Цикл
		НовСтр = Результат.Добавить();
		ТекСтр = Текст.ПолучитьСтроку(НомСтр);
		Колонки = СтрРазделить_1(ТекСтр, Символы.Таб, Ложь);
		Для НомКол = 0 По Колонки.ВГраница() Цикл
			НовСтр[НомКол] = Число(Колонки[НомКол]);
		КонецЦикла;
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

Функция ГенерирующийМногочлен(БайтовКоррекции)
	
	Текст = ПолучитьМакет("ГенерирующиеМногочлены");
	Для Ном = 1 По Текст.КоличествоСтрок() Цикл
		Многочлен = СтрРазделить_1(Текст.ПолучитьСтроку(Ном), Символы.Таб);
		Если Число(Многочлен[0]) = БайтовКоррекции Тогда
			Прервать;
		КонецЕсли;
	КонецЦикла;
	
	Результат = Новый Массив;
	Члены = СтрРазделить_1(Многочлен[1], " ");
	МаксИнд = Члены.ВГраница();
	Для Инд = 0 По МаксИнд Цикл
		Результат.Добавить(Число(Члены[МаксИнд - Инд]));
	КонецЦикла;
	Возврат Результат;	
	
	//Результат = Новый Массив;
	//Для Инд = 1 По Члены.ВГраница() Цикл
	//	Поз = СтрНайти(Члены[Инд], "x");
	//	Если Поз = 0 Тогда
	//		Коэф = Члены[Инд];
	//	ИначеЕсли Поз = 1 Тогда
	//		Коэф = "0";
	//	Иначе
	//		Коэф = Лев(Члены[Инд], Поз - 1);
	//	КонецЕсли;
	//	Результат.Вставить(Число(Коэф));
	//КонецЦикла;
	//Возврат Результат;
	
КонецФункции

Функция ПоляГалуа()
	
	ПрямоеПоле = Новый Соответствие;
	ОбратноеПоле = Новый Соответствие;	
	Текст = ПолучитьМакет("ПолеГалуа");
	Для НомСтр = 1 По Текст.КоличествоСтрок() Цикл
		ТекЧисло = Число(Текст.ПолучитьСтроку(НомСтр));
		ПрямоеПоле.Вставить(НомСтр - 1, ТекЧисло);
		ОбратноеПоле.Вставить(ТекЧисло, НомСтр - 1);
	КонецЦикла;
	
	Возврат Новый Структура("ПрямоеПоле,ОбратноеПоле", ПрямоеПоле, ОбратноеПоле);
	
КонецФункции

Функция ПереводИз10в2()
	
	Результат = Новый Соответствие;
	Результат.Вставить(0, "00000000");
	Для Сч = 1 По 255 Цикл
		Результат.Вставить(Сч, Из10в2(Сч, 8));
	КонецЦикла;
	Возврат Результат;
	
КонецФункции

Функция Из10в2(Число, Разрядность)
	
	Результат = Из10вЛюбую(Число, "01");
	Результат = Число(Результат);
	Возврат Формат(Результат, "ЧЦ=" + Разрядность + "; ЧВН=; ЧГ=");
	
КонецФункции

Функция Из10вЛюбую(Знач Значение, Шаблон)
	
    Результат = "";
    Основание = СтрДлина(Шаблон);
    Пока Значение > 0 цикл
        Остат = Значение % Основание;
        Результат1 = Сред(Шаблон, Остат + 1, 1);
        Значение = (Значение - Остат) / Основание;
        Результат = Результат1 + Результат;
    КонецЦикла;
    Возврат Результат;
	
КонецФункции

#КонецОбласти

#Область Низкоуровневое_кодирование

Функция РазместитьИнформацию(БайтыДанных)
	
	Областей = Sqrt(ПараметрыКода.ВсегоОбластей);
	РазмерХолста = ПараметрыКода.РазмерОбласти * Областей;
	Холст = Новый Массив(РазмерХолста, РазмерХолста);
	МаксМодуль = Холст.ВГраница();
	
	#Область ДобавлениеДанных
	
	Ряд = 4;
	Кол = 0;
	ТекБайт = 0;
	
	Пока Ряд < РазмерХолста Или Кол < РазмерХолста Цикл
		
		Если Ряд = РазмерХолста И Кол = 0 Тогда
			НарисоватьУгол1(Холст, БайтыДанных[ТекБайт]);
			ТекБайт = ТекБайт + 1;
		КонецЕсли;
		Если Ряд = РазмерХолста - 2 И Кол = 0 И РазмерХолста % 4 <> 0 Тогда
			НарисоватьУгол2(Холст, БайтыДанных[ТекБайт]);
			ТекБайт = ТекБайт + 1;
		КонецЕсли;
		Если Ряд = РазмерХолста - 2 И Кол = 0 И РазмерХолста % 8 = 4 Тогда
			НарисоватьУгол3(Холст, БайтыДанных[ТекБайт]);
			ТекБайт = ТекБайт + 1;
		КонецЕсли;
		Если Ряд = РазмерХолста + 4 И Кол = 2 И РазмерХолста % 8 = 0 Тогда
			НарисоватьУгол4(Холст, БайтыДанных[ТекБайт]);
			ТекБайт = ТекБайт + 1;
		КонецЕсли;
		
		Пока Ряд >= 0 И Кол < РазмерХолста Цикл
			Если Ряд < РазмерХолста И Кол >= 0 И Холст[Ряд][Кол] = Неопределено Тогда
				НарисоватьШтатЮта(Холст, Ряд, Кол, БайтыДанных[ТекБайт]);
				ТекБайт = ТекБайт + 1;
			КонецЕсли;
			Ряд = Ряд - 2;
			Кол = Кол + 2;
		КонецЦикла;
		
		Ряд = Ряд + 1;
		Кол = Кол + 3;
		
		Пока Ряд < РазмерХолста И Кол >= 0 Цикл
			Если Ряд >= 0 И Кол < РазмерХолста И Холст[Ряд][Кол] = Неопределено Тогда
				НарисоватьШтатЮта(Холст, Ряд, Кол, БайтыДанных[ТекБайт]);
				ТекБайт = ТекБайт + 1;
			КонецЕсли;
			Ряд = Ряд + 2;
			Кол = Кол - 2;
		КонецЦикла;
		
		Ряд = Ряд + 3;
		Кол = Кол + 1;
		
	КонецЦикла;
	
	Если Холст[МаксМодуль][МаксМодуль] = Неопределено Тогда
		Для Ряд = 0 По 1 Цикл
			Для Кол = 0 По 1 Цикл
				Холст[МаксМодуль - Ряд][МаксМодуль - Кол] = ?(Ряд = Кол, 1, 0);
			КонецЦикла;
		КонецЦикла;
	КонецЕсли;
	
	#КонецОбласти
	
	#Область ШаблонПоиска
			
	Цвет = 1;
	Для каждого Ряд Из Холст Цикл
		Для Сч = 1 По Областей Цикл
			Ряд.Вставить(ПараметрыКода.РазмерОбласти * (Областей - Сч + 1), Цвет);
			Ряд.Вставить(ПараметрыКода.РазмерОбласти * (Областей - Сч), 1);
		КонецЦикла;
		Цвет = 1 - Цвет;
	КонецЦикла;
	
	ГоризонтЛиния = Новый Массив;
	ГоризонтПунктир = Новый Массив;
	Для Сч = 1 По ПараметрыКода.РазмерКода Цикл
		ГоризонтЛиния.Добавить(1);
		ГоризонтПунктир.Добавить(Сч % 2);
	КонецЦикла;
	ГоризонтЛиния = Новый ФиксированныйМассив(ГоризонтЛиния);
	ГоризонтПунктир = Новый ФиксированныйМассив(ГоризонтПунктир);
	
	Для Сч = 1 По Областей Цикл
		Холст.Вставить(ПараметрыКода.РазмерОбласти * (Областей - Сч + 1), Новый Массив(ГоризонтЛиния));
		Холст.Вставить(ПараметрыКода.РазмерОбласти * (Областей - Сч), Новый Массив(ГоризонтПунктир));
	КонецЦикла;
	
	#КонецОбласти
	
	//Пометка как личная подпись
	Если Областей = 2 Тогда
		Середина = ПараметрыКода.РазмерКода / 2;
		Холст[Середина-1][Середина] = 0;
	КонецЕсли;
	
	#Область ДобавлениеОтступа
		
	Для каждого Ряд Из Холст Цикл
		Для Сч = 1 По ШиринаРамки Цикл
			Ряд.Вставить(0, 0);
			Ряд.Добавить(0);
		КонецЦикла;
	КонецЦикла;
	
	БелыйРяд = Новый Массив;
	Для Сч = 1 По ПараметрыКода.РазмерКода + ШиринаРамки * 2 Цикл
		БелыйРяд.Добавить(0);
	КонецЦикла;
	
	Для Сч = 1 По ШиринаРамки Цикл
		Холст.Вставить(0, БелыйРяд);
		Холст.Добавить(БелыйРяд);
	КонецЦикла;
	
	#КонецОбласти
	
	Возврат Холст;
	
КонецФункции	

Функция СоздатьКартинку(Холст)
	РазмерЭлемента=20;

	РазмерХолста = Холст.Количество();
	Высота = РазмерХолста * РазмерЭлемента;
	Ширина = РазмерХолста * РазмерЭлемента;
	
	// Для простоты формирования возьемём 24 бита. По 8 бит на каждый канал. Альфаканал не используем. 
	ГлубинаЦвета = 3; // Измеряется в байтах. 	
	
	// Каждая строка должна содержать количество байтов кратное 4.
	БайтовДополнение = (4 - ГлубинаЦвета * Ширина % 4) % 4; 
	
	РазмерФайла = ГлубинаЦвета * Ширина * Высота + Высота * БайтовДополнение;	
	
	///////////////////////////////////////////////////////////////////////////////
		
	ПотокТело = Новый ПотокВПамяти();
	ЗаписьДанных = Новый ЗаписьДанных(ПотокТело);
		
	//BITMAPFILEHEADER
	
	//bfType 
	ЗаписьДанных.ЗаписатьЦелое16(16973, ПорядокБайтов.BigEndian); // 0x424D big-endian = 0x4D42 little-endian. Признак формата. Всегда это значение.
	//bfSize
	ЗаписьДанных.ЗаписатьЦелое32(54 + РазмерФайла);
	//bfReserved1
	ЗаписьДанных.ЗаписатьЦелое16(0);	
	//bfReserved2
	ЗаписьДанных.ЗаписатьЦелое16(0);	
	//bfOffBits
	ЗаписьДанных.ЗаписатьЦелое32(54);
	
	//BITMAPINFOHEADER // версия 3
	// biSize
	ЗаписьДанных.ЗаписатьЦелое32(40); 
	// biWidth
	ЗаписьДанных.ЗаписатьЦелое32(Ширина);			// ширина изображения в пикселах 
	// biHeight
	ЗаписьДанных.ЗаписатьЦелое32(Высота);			// высота изображения в пикселах
	// biPlanes
	ЗаписьДанных.ЗаписатьЦелое16(1);				// содержит единицу
	// biBitCount
	ЗаписьДанных.ЗаписатьЦелое16(ГлубинаЦвета * 8);	// количество бит на пиксел 
	// biCompression
	ЗаписьДанных.ЗаписатьЦелое32(0);				// тип сжатия 
	// biSizeImage
	ЗаписьДанных.ЗаписатьЦелое32(РазмерФайла);		// размер изображения в байтах
	// biXPelsPerMeter
	ЗаписьДанных.ЗаписатьЦелое32(0);				// горизонтальное разрешение в пикселах на метр 
	// biYPelsPerMeter
	ЗаписьДанных.ЗаписатьЦелое32(0); 				// вертикальное разрешение в пикселах на метр 
	// biClrUsed
	ЗаписьДанных.ЗаписатьЦелое32(0);				//  количество используемых цветовых индексов в палитре 
	// biClrImportant
	ЗаписьДанных.ЗаписатьЦелое32(0);				// количество индексов
	
	///////////////////////////////////////////////////////////////////////////////
	
	БелаяПолоса = Новый БуферДвоичныхДанных(РазмерЭлемента * ГлубинаЦвета);
	ЧернаяПолоса = Новый БуферДвоичныхДанных(РазмерЭлемента * ГлубинаЦвета);
	
	Для Инд = 0 По БелаяПолоса.Размер - 1 Цикл
		БелаяПолоса.Установить(Инд, 255);
		ЧернаяПолоса.Установить(Инд, 0);
	КонецЦикла;
	
	МаксМодуль = РазмерХолста - 1;
	Для Выс = 0 По МаксМодуль Цикл	// строки снизу вверх		
		
		ВесьРяд = Новый БуферДвоичныхДанных(Ширина * ГлубинаЦвета + БайтовДополнение);
		
		Для Шир = 0 По МаксМодуль Цикл
			
			Значение = Холст[МаксМодуль - Выс][Шир];
			  			
			Если Значение = 0 Тогда
				ЗаписьДанных.ЗаписатьБуферДвоичныхДанных(БелаяПолоса);
				ВесьРяд.Записать(Шир * БелаяПолоса.Размер, БелаяПолоса);
			Иначе
				ЗаписьДанных.ЗаписатьБуферДвоичныхДанных(ЧернаяПолоса);
				ВесьРяд.Записать(Шир * ЧернаяПолоса.Размер, ЧернаяПолоса);
			КонецЕсли;
						
		КонецЦикла;
		
		// Забиваем нулями остаток строки. Так как размер строки должен быть кратен 4 байтам.
		Для Доп = 1 По БайтовДополнение Цикл		
			ЗаписьДанных.ЗаписатьБайт(0);
			ВесьРяд.Установить(ВесьРяд.Размер - Доп, 0);
		КонецЦикла;
		
		Для Сч = 1 По РазмерЭлемента - 1 Цикл
			ЗаписьДанных.ЗаписатьБуферДвоичныхДанных(ВесьРяд);
		КонецЦикла;
		
	КонецЦикла;
		
	ЗаписьДанных.Закрыть();	
	Возврат ПотокТело.ЗакрытьИПолучитьДвоичныеДанные();
		
КонецФункции

Процедура НарисоватьТочку(Холст, Знач Ряд, Знач Кол, Байт, Разряд)
	
	Если Ряд < 0 Тогда
		Ряд = Ряд + Холст.Количество();
		Кол = Кол + 4 - (Холст.Количество() + 4) % 8;
	КонецЕсли;
	
	Если Кол < 0 Тогда
		Кол = Кол + Холст.Количество();
		Ряд = Ряд + 4 - (Холст.Количество() + 4) % 8;
	КонецЕсли;
	
	Холст[Ряд][Кол] = Число(Сред(Байт, Разряд, 1));
	
КонецПроцедуры

Процедура НарисоватьШтатЮта(Холст, Ряд, Кол, Байт)
	
	НарисоватьТочку(Холст, Ряд - 2, Кол - 2, Байт, 1);
	НарисоватьТочку(Холст, Ряд - 2, Кол - 1, Байт, 2);
	НарисоватьТочку(Холст, Ряд - 1, Кол - 2, Байт, 3);
	НарисоватьТочку(Холст, Ряд - 1, Кол - 1, Байт, 4);
	НарисоватьТочку(Холст, Ряд - 1, Кол, 	 Байт, 5);
	НарисоватьТочку(Холст, Ряд, 	Кол - 2, Байт, 6);
	НарисоватьТочку(Холст, Ряд, 	Кол - 1, Байт, 7);
	НарисоватьТочку(Холст, Ряд, 	Кол, 	 Байт, 8);
	
КонецПроцедуры

Процедура НарисоватьУгол1(Холст, Байт)
	
	НарисоватьТочку(Холст, Холст.Количество() - 1, 0, Байт, 1);
	НарисоватьТочку(Холст, Холст.Количество() - 1, 1, Байт, 2);
	НарисоватьТочку(Холст, Холст.Количество() - 1, 2, Байт, 3);
	НарисоватьТочку(Холст, 0, Холст.Количество() - 2, Байт, 4);
	НарисоватьТочку(Холст, 0, Холст.Количество() - 1, Байт, 5);
	НарисоватьТочку(Холст, 1, Холст.Количество() - 1, Байт, 6);
	НарисоватьТочку(Холст, 2, Холст.Количество() - 1, Байт, 7);
	НарисоватьТочку(Холст, 3, Холст.Количество() - 1, Байт, 8);
	
КонецПроцедуры

Процедура НарисоватьУгол2 (Холст, Байт)
	
	НарисоватьТочку(Холст, Холст.Количество() - 3, 0, Байт, 1);
	НарисоватьТочку(Холст, Холст.Количество() - 2, 0, Байт, 2);
	НарисоватьТочку(Холст, Холст.Количество() - 1, 0, Байт, 3);
	НарисоватьТочку(Холст, 0, Холст.Количество() - 4, Байт, 4);
	НарисоватьТочку(Холст, 0, Холст.Количество() - 3, Байт, 5);
	НарисоватьТочку(Холст, 0, Холст.Количество() - 2, Байт, 6);
	НарисоватьТочку(Холст, 0, Холст.Количество() - 1, Байт, 7);
	НарисоватьТочку(Холст, 1, Холст.Количество() - 1, Байт, 8);
	
КонецПроцедуры

Процедура НарисоватьУгол3(Холст, Байт)
	
	НарисоватьТочку(Холст, Холст.Количество() - 3, 0, Байт, 1);
	НарисоватьТочку(Холст, Холст.Количество() - 2, 0, Байт, 2);
	НарисоватьТочку(Холст, Холст.Количество() - 1, 0, Байт, 3);
	НарисоватьТочку(Холст, 0, Холст.Количество() - 2, Байт, 4);
	НарисоватьТочку(Холст, 0, Холст.Количество() - 1, Байт, 5);
	НарисоватьТочку(Холст, 1, Холст.Количество() - 1, Байт, 6);
	НарисоватьТочку(Холст, 2, Холст.Количество() - 1, Байт, 7);
	НарисоватьТочку(Холст, 3, Холст.Количество() - 1, Байт, 8);
	
КонецПроцедуры

Процедура НарисоватьУгол4(Холст, Байт)
	
	НарисоватьТочку(Холст, Холст.Количество() - 1, 0, Байт, 1);
	НарисоватьТочку(Холст, Холст.Количество() - 1, Холст.Количество() - 1, Байт, 2);
	НарисоватьТочку(Холст, 0, Холст.Количество() - 3, Байт,3);
	НарисоватьТочку(Холст, 0, Холст.Количество() - 2, Байт,4);
	НарисоватьТочку(Холст, 0, Холст.Количество() - 1, Байт,5);
	НарисоватьТочку(Холст, 1, Холст.Количество() - 3, Байт,6);
	НарисоватьТочку(Холст, 1, Холст.Количество() - 2, Байт,7);
	НарисоватьТочку(Холст, 1, Холст.Количество() - 1, Байт,8);
	
КонецПроцедуры

#КонецОбласти

Функция СтрРазделить_1(Знач Значение, Знач Разделитель = ",", Знач ВключатьПустые = Истина) Экспорт
	
	Результат = Новый Массив;
	
	Позиция = Найти(Значение, Разделитель);
	Пока Позиция > 0 Цикл
		Подстрока = Лев(Значение, Позиция - 1);
		Если ВключатьПустые Или Не ПустаяСтрока(Подстрока) Тогда
			Результат.Добавить(Подстрока);
		КонецЕсли;
		Значение = Сред(Значение, Позиция + СтрДлина(Разделитель));
		Позиция = Найти(Значение, Разделитель);
	КонецЦикла;
	
	Если ВключатьПустые Или Не ПустаяСтрока(Значение) Тогда
		Результат.Добавить(Значение);
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции


Функция Сгенерировать13(ИсходнаяСтрока,ИНН="") Экспорт
	Попытка

	Если СтрДлина(ИсходнаяСтрока) = 7 Или СтрДлина(ИсходнаяСтрока) = 8 Тогда
		КодированнаяСтрока = ЗакодироватьДанные8(ИсходнаяСтрока);
	ИначеЕсли СтрДлина(ИсходнаяСтрока) = 12 Или СтрДлина(ИсходнаяСтрока) = 13 Тогда
		КодированнаяСтрока = ЗакодироватьДанные13(ИсходнаяСтрока);
	Иначе
		ВызватьИсключение "Указан код неверной длины";
	КонецЕсли;
	
	Холст = РазместитьИнформацию13(КодированнаяСтрока);
	Возврат СоздатьКартинку13(Холст);
Исключение
	Возврат Неопределено
	КонецПопытки;
КонецФункции

Функция ЗакодироватьДанные13(Знач ИсходнаяСтрока)
	   	
	ean13m = Новый Массив(10);
	ean13m[0] = "000000";
	ean13m[1] = "001011";
	ean13m[2] = "001101";
	ean13m[3] = "001110";
	ean13m[4] = "010011";
	ean13m[5] = "011001";
	ean13m[6] = "011100";
	ean13m[7] = "010101";
	ean13m[8] = "010110";
	ean13m[9] = "011010";
	
	ean = КодыЦифр13();
	Результат = "111";
	Если СтрДлина(ИсходнаяСтрока) = 13 тогда
		ИсходнаяСтрока = Лев(ИсходнаяСтрока, 12);
	ИначеЕсли СтрДлина(ИсходнаяСтрока)<>12 тогда
		Возврат "";
	КонецЕсли;
	кс = Число(Лев(ИсходнаяСтрока, 1));
	м = ean13m[Число(Лев(ИсходнаяСтрока, 1))];
	Для Н = 2 по 7 цикл
		ТекЧисло = Число(Сред(ИсходнаяСтрока, Н, 1));
		кс = кс + ТекЧисло * (((Н + 1) % 2) * 2 + 1);
		Знак = ean[ТекЧисло];
		Результат = Результат + ?(Сред(м, Н - 1, 1) = "0", Знак, ПеревернутьСтроку13(Знак));
	КонецЦикла;
	Результат = Результат + "11111";
	Для Н = 8 по 12 цикл
		ТекЧисло = Число(Сред(ИсходнаяСтрока, Н, 1));
		кс = кс + ТекЧисло * (((Н + 1) % 2) * 2 + 1);
		Знак = ean[ТекЧисло];
		Результат = Результат + Знак;
	КонецЦикла;
	кс = (10 - кс % 10) % 10;
	ИсходнаяСтрока = ИсходнаяСтрока + кс;
	Возврат Результат + ean[кс] + "111";
	
КонецФункции

Функция ЗакодироватьДанные8(Знач ИсходнаяСтрока) Экспорт
	
	ean = КодыЦифр13();
	Результат = "111";
	Если СтрДлина(ИсходнаяСтрока) = 8 тогда
		ИсходнаяСтрока = Лев(ИсходнаяСтрока, 7);
	ИначеЕсли СтрДлина(ИсходнаяСтрока) <> 7 тогда
		возврат "";
	КонецЕсли;
	кс = 0;
	Для Н = 1 по 7 цикл
		ТекЧисло = Число(Сред(ИсходнаяСтрока, Н, 1));
		кс = кс + ТекЧисло * ((Н % 2) * 2 + 1);
		Результат = Результат + ean[ТекЧисло];
		Если Н = 4 тогда
			Результат = Результат + "11111";
		КонецЕсли;
	КонецЦикла;
	кс = (10 - кс % 10) % 10;
	ИсходнаяСтрока = ИсходнаяСтрока + кс;
	возврат Результат + ean[кс] + "111";
	
КонецФункции

Функция КодыЦифр13()
	
	ean = Новый Массив(10);
	ean[0] = "3211";
	ean[1] = "2221";
	ean[2] = "2122";
	ean[3] = "1411";
	ean[4] = "1132";
	ean[5] = "1231";
	ean[6] = "1114";
	ean[7] = "1312";
	ean[8] = "1213";
	ean[9] = "3112";
	Возврат ean;
	
КонецФункции

Функция РазместитьИнформацию13(КодированнаяСтрока)
	
	ТекЦвет = 1;
	Результат = Новый Массив;
	Для Сч = 1 По ШиринаРамки Цикл
		Результат.Добавить(0);
	КонецЦикла;
	Для Симв = 1 По СтрДлина(КодированнаяСтрока) Цикл
		Для Сч = 1 По Число(Сред(КодированнаяСтрока, Симв, 1)) Цикл
			Результат.Добавить(ТекЦвет);
		КонецЦикла;
		ТекЦвет = 1 - ТекЦвет;
	КонецЦикла;
	Для Сч = 1 По ШиринаРамки Цикл
		Результат.Добавить(0);
	КонецЦикла;
	Возврат Результат;
	
КонецФункции

Функция ПеревернутьСтроку13(ИсходнаяСтрока)
	
	Результат = "";
	Длина = СтрДлина(ИсходнаяСтрока);
	Для Н = 0 по Длина - 1 Цикл
		Результат = Результат + Сред(ИсходнаяСтрока, Длина-Н, 1);
	КонецЦикла;
	Возврат Результат;
	
КонецФункции

Функция СоздатьКартинку13(Холст)
	ВысотаКартинки=40;
	РазмерЭлемента=2;
	
	
	
	РазмерХолста = Холст.Количество();
	Высота = ВысотаКартинки;
	Ширина = РазмерХолста * РазмерЭлемента;
	
	// Для простоты формирования возьемём 24 бита. По 8 бит на каждый канал. Альфаканал не используем. 
	ГлубинаЦвета = 3; // Измеряется в байтах. 	
	
	// Каждая строка должна содержать количество байтов кратное 4.
	БайтовДополнение = (4 - ГлубинаЦвета * Ширина % 4) % 4; 
	
	РазмерФайла = ГлубинаЦвета * Ширина * Высота + Высота * БайтовДополнение;	
	
	///////////////////////////////////////////////////////////////////////////////
	
	БайтыКартинки = Новый Массив;
	
	//BITMAPFILEHEADER
		
	//bfType 
	БайтыКартинки.Добавить(КодСимвола("B"));
	БайтыКартинки.Добавить(КодСимвола("M"));
	//bfSize
	ЗаписатьЦелое32(БайтыКартинки, 54 + РазмерФайла);
	//bfReserved1
	ЗаписатьЦелое16(БайтыКартинки, 0);	
	//bfReserved2
	ЗаписатьЦелое16(БайтыКартинки, 0);	
	//bfOffBits
	ЗаписатьЦелое32(БайтыКартинки, 54);
	
	//BITMAPINFOHEADER // версия 3
	// biSize
	ЗаписатьЦелое32(БайтыКартинки, 40); 
	// biWidth
	ЗаписатьЦелое32(БайтыКартинки, Ширина);			// ширина изображения в пикселах 
	// biHeight
	ЗаписатьЦелое32(БайтыКартинки, Высота);			// высота изображения в пикселах
	// biPlanes
	ЗаписатьЦелое16(БайтыКартинки, 1);				// содержит единицу
	// biBitCount
	ЗаписатьЦелое16(БайтыКартинки, ГлубинаЦвета * 8);	// количество бит на пиксел 
	// biCompression
	ЗаписатьЦелое32(БайтыКартинки, 0);				// тип сжатия 
	// biSizeImage
	ЗаписатьЦелое32(БайтыКартинки, РазмерФайла);		// размер изображения в байтах
	// biXPelsPerMeter
	ЗаписатьЦелое32(БайтыКартинки, 0);				// горизонтальное разрешение в пикселах на метр 
	// biYPelsPerMeter
	ЗаписатьЦелое32(БайтыКартинки, 0); 				// вертикальное разрешение в пикселах на метр 
	// biClrUsed
	ЗаписатьЦелое32(БайтыКартинки, 0);				//  количество используемых цветовых индексов в палитре 
	// biClrImportant
	ЗаписатьЦелое32(БайтыКартинки, 0);				// количество индексов
	
	///////////////////////////////////////////////////////////////////////////////
	
	БелаяПолоса = Новый Массив;
	ЧернаяПолоса = Новый Массив;
	
	Для Сч = 1 По РазмерЭлемента * ГлубинаЦвета Цикл
		БелаяПолоса.Добавить(255);
		ЧернаяПолоса.Добавить(0);
	КонецЦикла;
	
	МаксМодуль = РазмерХолста - 1;
	
	ВесьРяд = Новый Массив;
	
	Для Шир = 0 По МаксМодуль Цикл
		
		Значение = Холст[Шир];
		
		Если Значение = 0 Тогда
			СложитьМассивы13(ВесьРяд, БелаяПолоса);
		Иначе
			СложитьМассивы13(ВесьРяд, ЧернаяПолоса);
		КонецЕсли;
		
	КонецЦикла;
	
	// Забиваем нулями остаток строки. Так как размер строки должен быть кратен 4 байтам.
	Для Доп = 1 По БайтовДополнение Цикл
		ВесьРяд.Добавить(0);
	КонецЦикла;
	
	Для Сч = 1 По Высота Цикл
		СложитьМассивы13(БайтыКартинки, ВесьРяд);
	КонецЦикла;
	
	Возврат Base64Значение(СтрокаBase64(БайтыКартинки));
		
КонецФункции


Процедура СложитьМассивы13(Первый, Второй)
	
	Для каждого Эл Из Второй Цикл
		Первый.Добавить(Эл);
	КонецЦикла;
	
КонецПроцедуры

Процедура ЗаписатьЦелое16(МассивБайтов, Значение)
	
	МассивБайтов.Добавить(Значение);
	МассивБайтов.Добавить(0);
	
КонецПроцедуры

Процедура ЗаписатьЦелое32(МассивБайтов, Значение)
	
	МассивБайтов.Добавить(Значение % 256);
	МассивБайтов.Добавить(Цел((Значение % (256 * 256)) / 256));
	МассивБайтов.Добавить(Цел((Значение % (256 * 256 * 256)) / 256 / 256));
	МассивБайтов.Добавить(Цел(Значение / 256 / 256 / 256) % 256);
	
КонецПроцедуры

Функция СтрокаBase64(Байты)
	
	Результат = "";
	КолБайтов = Байты.Количество();
	Если КолБайтов = 0 тогда
		Возврат "";
	КонецЕсли;
	
	Символы64Строка = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
	Символы64 = Новый Массив();
	Для Сч = 1 По 64 Цикл
		Символы64.Добавить(Сред(Символы64Строка, Сч, 1));
	КонецЦикла;
	
	Попытка
		
		XML = Новый ЗаписьXML();
		XML.УстановитьСтроку();
		
		Для Ном = 0 по Цел(КолБайтов / 3) - 1 цикл
			XML.ЗаписатьБезОбработки(Символы64[Цел(Байты[Ном * 3] / 4)]                                          
			 + Символы64[(Байты[Ном * 3] % 4) * 16 + Цел(Байты[Ном * 3 + 1] / 16)]
			 + Символы64[(Байты[Ном * 3 + 1] % 16) * 4 + Цел(Байты[Ном * 3 + 2] / 64)]
			 + Символы64[(Байты[Ном * 3 + 2] % 64)]);
		КонецЦикла;
		Остаток = (КолБайтов % 3);
		Если Остаток > 0 тогда
			Ном = Цел(КолБайтов / 3) * 3;
			Число1 = Байты[Ном];
			Число2 = ?(Остаток > 1, Байты[Ном + 1], 0);
			Результат = Символы64[Цел(Число1 / 4)] + Символы64[(Число1 % 4) * 16 + Цел(Число2 / 16)];
			Если Остаток = 1 тогда
				Результат = Результат + "==";
			Иначе
				Результат = Результат + Символы64[(Число2 % 16) * 4] + "=";
			КонецЕсли;
			XML.ЗаписатьБезОбработки(Результат);
		КонецЕсли;
		Результат = XML.Закрыть();
		
	Исключение
		
		Строки = Новый Массив();
		Для Ном = 0 по Цел(КолБайтов / 3) - 1 цикл
			Строки.Добавить(Символы64[Цел(Байты[Ном * 3] / 4)]                                          
			 + Символы64[(Байты[Ном * 3] % 4) * 16 + Цел(Байты[Ном * 3 + 1] / 16)]
			 + Символы64[(Байты[Ном * 3 + 1] % 16) * 4 + Цел(Байты[Ном * 3 + 2] / 64)]
			 + Символы64[(Байты[Ном * 3 + 2] % 64)]);
		КонецЦикла;
		Остаток = (КолБайтов % 3);
		Если Остаток > 0 тогда
			Ном = Цел(КолБайтов / 3) * 3;
			Число1 = Байты[Ном];
			Число2 = ?(Остаток > 1, Байты[Ном + 1], 0);
			Результат = Символы64[Цел(Число1 / 4)] + Символы64[(Число1 % 4) * 16 + Цел(Число2 / 16)];
			Если Остаток = 1 тогда
				Результат = Результат + "==";
			Иначе
				Результат = Результат + Символы64[(Число2 % 16) * 4] + "=";
			КонецЕсли;
			Строки.Добавить(Результат);
		КонецЕсли;
		КолСтрок = Строки.Количество();
		Пока КолСтрок > 1 цикл
			Для Н = 0 по Цел(КолСтрок / 2) - 1 Цикл
				Строки[Н] = Строки[н * 2] + Строки[н * 2 + 1];
			КонецЦикла;
			Если (КолСтрок % 2) = 1 тогда
				Строки[Цел(КолСтрок / 2)] = Строки[КолСтрок - 1];
			КонецЕсли;
			КолСтрок = Цел(КолСтрок / 2) + КолСтрок % 2;
		КонецЦикла;
		Результат = Строки[0];
		
	КонецПопытки;
	Возврат Результат;
	
КонецФункции


Функция Сгенерировать128(ИсходнаяСтрока,ИНН="") Экспорт
	Попытка
	КодированнаяСтрока = ЗакодироватьДанные128(ИсходнаяСтрока);
	Холст = РазместитьИнформацию128(КодированнаяСтрока);
	Возврат СоздатьКартинку128(Холст);
Исключение
	Возврат Неопределено
	КонецПопытки;
КонецФункции

Функция ЗакодироватьДанные128(Знач ИсходнаяСтрока)
	
	Коды = Новый Массив(108);
	Стр = 
	"212222,222122,222221,121223,121322,131222,122213,122312," + 
	"132212,221213,221312,231212,112232,122132,122231,113222," + 
	"123122,123221,223211,221132,221231,213212,223112,312131," + 
	"311222,321122,321221,312212,322112,322211,212123,212321," + 
	"232121,111323,131123,131321,112313,132113,132311,211313," + 
	"231113,231311,112133,112331,132131,113123,113321,133121," + 
	"313121,211331,231131,213113,213311,213131,311123,311321," + 
	"331121,312113,312311,332111,314111,221411,431111,111224," + 
	"111422,121124,121421,141122,141221,112214,112412,122114," + 
	"122411,142112,142211,241211,221114,413111,241112,134111," + 
	"111242,121142,121241,114212,124112,124211,411212,421112," + 
	"421211,212141,214121,412121,111143,111341,131141,114113," + 
	"114311,411113,411311,113141,114131,311141,411131,211412," + 
	"211214,211232,2331112,";

	Ном = 1;
	Пока Найти(Стр, ",") > 0 Цикл
		Поз = Найти(Стр, ",");
		Код = Лев(Стр, Поз - 1);
		Стр = Сред(Стр, Поз + 1);
		Коды[Ном] = Код;
		Ном = Ном + 1;
	КонецЦикла;
	
	Результат = "";
	
	bCode = "";
	curMode = символ(0);
	Ном = 1;
	Пока Ном <= СтрДлина(ИсходнаяСтрока) Цикл
		КодСимв = КодСимвола(Сред(ИсходнаяСтрока, Ном, 1));
		Ном = Ном + 1;
		Если КодСимв > 127 Тогда
			Возврат "";
		КонецЕсли;
		Если Ном <= СтрДлина(ИсходнаяСтрока) Тогда
			КодСимв2 = КодСимвола(Сред(ИсходнаяСтрока, Ном, 1));
		Иначе
			КодСимв2 = 0;
		КонецЕсли;
		Если (КодСимв >= 48) and ((КодСимв <= 57)) and (КодСимв2 >= 48) and (КодСимв2 <= 57) Тогда 
			Ном = Ном + 1;
			Если bCode = "" Тогда 
				curMode = "C";
				bCode = bCode + "i" //#$69; //"i" CODE - C
			ИначеЕсли curMode <> "C" Тогда 
				curMode = "C";
				bCode = bCode + "c"; //#$63; //"c"
			КонецЕсли;
			bCode = bCode + Символ((КодСимв - 48) * 10 + (КодСимв2 - 48));
		Иначе
			Если bCode = "" Тогда 
				Если КодСимв < 32 Тогда  //" "
					curMode = "A";
					bCode = bCode + "g"; //#$67; //"g" CODE - A
				Иначе
					curMode = "B";
					bCode = bCode + "h"; //#$68; //"h" CODE - B
				КонецЕсли;
			КонецЕсли;
			Если (КодСимв < 32) and  (curMode <> "A") Тогда 
				curMode = "A";
				bCode = bCode + "e"; //#$65; //"e"
			ИначеЕсли ((КодСимв >= 64) and (curMode <> "B")) Или (curMode = "C") Тогда 
				curMode = "B";
				bCode = bCode + "d"; //#$64; //"d"
			КонецЕсли;
			Если (КодСимв < 32) Тогда 
				bCode = bCode + Символ(КодСимв + 64); //"@"
			Иначе
				bCode = bCode + Символ(КодСимв - 32); //" "
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	Если bCode <> "" Тогда
		cCode = КодСимвола(bCode); // - цел(КодСимв(bCode)/103)  //"g"
	Иначе
		cCode = 0;
	КонецЕсли;
	Для Сч = 1 По СтрДлина(bCode) - 1 Цикл
		cCode = (cCode + КодСимвола(Сред(bCode, Сч + 1, 1)) * Сч); //mod $67;
	КонецЦикла;
	cCode = cCode - Цел(cCode/103) * 103;
	bCode = bCode + Символ(cCode) + "j"; //#$6a; //"j" CODE - @
	Для Сч = 1 По СтрДлина(bCode) Цикл 
      Результат = Результат + (Коды[КодСимвола(Сред(bCode, Сч, 1)) + 1]);
    КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

Функция РазместитьИнформацию128(КодированнаяСтрока)
	
	ТекЦвет = 1;
	Результат = Новый Массив;
	Для Сч = 1 По ШиринаРамки Цикл
		Результат.Добавить(0);
	КонецЦикла;
	Для Симв = 1 По СтрДлина(КодированнаяСтрока) Цикл
		Для Сч = 1 По Число(Сред(КодированнаяСтрока, Симв, 1)) Цикл
			Результат.Добавить(ТекЦвет);
		КонецЦикла;
		ТекЦвет = 1 - ТекЦвет;
	КонецЦикла;
	Для Сч = 1 По ШиринаРамки Цикл
		Результат.Добавить(0);
	КонецЦикла;
	Возврат Результат;
	
КонецФункции

Функция СоздатьКартинку128(Холст)
	 ВысотаКартинки=	100;
	 РазмерЭлемента=1;
	
	РазмерХолста = Холст.Количество();
	Высота = ВысотаКартинки;
	Ширина = РазмерХолста * РазмерЭлемента;
	
	// Для простоты формирования возьемём 24 бита. По 8 бит на каждый канал. Альфаканал не используем. 
	ГлубинаЦвета = 3; // Измеряется в байтах. 	
	
	// Каждая строка должна содержать количество байтов кратное 4.
	БайтовДополнение = (4 - ГлубинаЦвета * Ширина % 4) % 4; 
	
	РазмерФайла = ГлубинаЦвета * Ширина * Высота + Высота * БайтовДополнение;	
	
	///////////////////////////////////////////////////////////////////////////////
	
	БайтыКартинки = Новый Массив;
	
	//BITMAPFILEHEADER
		
	//bfType 
	БайтыКартинки.Добавить(КодСимвола("B"));
	БайтыКартинки.Добавить(КодСимвола("M"));
	//bfSize
	ЗаписатьЦелое32(БайтыКартинки, 54 + РазмерФайла);
	//bfReserved1
	ЗаписатьЦелое16(БайтыКартинки, 0);	
	//bfReserved2
	ЗаписатьЦелое16(БайтыКартинки, 0);	
	//bfOffBits
	ЗаписатьЦелое32(БайтыКартинки, 54);
	
	//BITMAPINFOHEADER // версия 3
	// biSize
	ЗаписатьЦелое32(БайтыКартинки, 40); 
	// biWidth
	ЗаписатьЦелое32(БайтыКартинки, Ширина);			// ширина изображения в пикселах 
	// biHeight
	ЗаписатьЦелое32(БайтыКартинки, Высота);			// высота изображения в пикселах
	// biPlanes
	ЗаписатьЦелое16(БайтыКартинки, 1);				// содержит единицу
	// biBitCount
	ЗаписатьЦелое16(БайтыКартинки, ГлубинаЦвета * 8);	// количество бит на пиксел 
	// biCompression
	ЗаписатьЦелое32(БайтыКартинки, 0);				// тип сжатия 
	// biSizeImage
	ЗаписатьЦелое32(БайтыКартинки, РазмерФайла);		// размер изображения в байтах
	// biXPelsPerMeter
	ЗаписатьЦелое32(БайтыКартинки, 0);				// горизонтальное разрешение в пикселах на метр 
	// biYPelsPerMeter
	ЗаписатьЦелое32(БайтыКартинки, 0); 				// вертикальное разрешение в пикселах на метр 
	// biClrUsed
	ЗаписатьЦелое32(БайтыКартинки, 0);				//  количество используемых цветовых индексов в палитре 
	// biClrImportant
	ЗаписатьЦелое32(БайтыКартинки, 0);				// количество индексов
	
	///////////////////////////////////////////////////////////////////////////////
	
	БелаяПолоса = Новый Массив;
	ЧернаяПолоса = Новый Массив;
	
	Для Сч = 1 По РазмерЭлемента * ГлубинаЦвета Цикл
		БелаяПолоса.Добавить(255);
		ЧернаяПолоса.Добавить(0);
	КонецЦикла;
	
	МаксМодуль = РазмерХолста - 1;
	
	ВесьРяд = Новый Массив;
	
	Для Шир = 0 По МаксМодуль Цикл
		
		Значение = Холст[Шир];
		
		Если Значение = 0 Тогда
			СложитьМассивы128(ВесьРяд, БелаяПолоса);
		Иначе
			СложитьМассивы128(ВесьРяд, ЧернаяПолоса);
		КонецЕсли;
		
	КонецЦикла;
	
	// Забиваем нулями остаток строки. Так как размер строки должен быть кратен 4 байтам.
	Для Доп = 1 По БайтовДополнение Цикл
		ВесьРяд.Добавить(0);
	КонецЦикла;
	
	Для Сч = 1 По Высота Цикл
		СложитьМассивы128(БайтыКартинки, ВесьРяд);
	КонецЦикла;
	
	Возврат Base64Значение(СтрокаBase64(БайтыКартинки));
		
КонецФункции


Процедура СложитьМассивы128(Первый, Второй)
	
	Для каждого Эл Из Второй Цикл
		Первый.Добавить(Эл);
	КонецЦикла;
	
КонецПроцедуры

