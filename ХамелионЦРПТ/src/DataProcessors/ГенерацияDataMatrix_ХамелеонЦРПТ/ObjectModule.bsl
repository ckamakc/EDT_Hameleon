
Перем ПараметрыКода;
Перем ПобитИсклИли Экспорт;

Функция Инициализировать() Экспорт
	
	ПобитИсклИли = ЗначениеИзСтрокиВнутр(ПолучитьМакет("ПобитовоеИсключающееИли").ПолучитьТекст());
	
КонецФункции

Функция Сгенерировать(Знач ИсходнаяСтрока) Экспорт
	
	Если РегистрыСведений.НастройкиПрограммы_ХамелеонЦРПТ.Получить().ДобавитьДваНуля Тогда
	//	ИсходнаяСтрока=Символ(232)+ИсходнаяСтрока;
//		ИсходнаяСтрока=РаскодироватьСтроку("%1D",СпособКодированияСтроки.КодировкаURL)+ИсходнаяСтрока;
	//	ИсходнаяСтрока=РаскодироватьСтроку("%E8",СпособКодированияСтроки.КодировкаURL)+РаскодироватьСтроку("%1D",СпособКодированияСтроки.КодировкаURL)+ИсходнаяСтрока;
	КонецЕсли;
	
	КодыСимволов = ЗакодироватьДанные(ИсходнаяСтрока);
	БайтыСимволов = ДобавитьСлужебнуюИнформацию(КодыСимволов);
	Блоки = РазделитьИнформациюНаБлоки(БайтыСимволов);
	БайтыКоррекции = СоздатьБайтыКоррекции(Блоки);
	БайтыДанных = ОбъединитьБлоки(Блоки, БайтыКоррекции);
	Холст = РазместитьИнформацию(БайтыДанных);
	Возврат СоздатьКартинку(Холст);
		
КонецФункции

#Область Высокоуровневое_кодирование

Функция ЗакодироватьДанные(Знач ИсходнаяСтрока)
	
	Результат = Новый Массив;
	КодЦифры0 = 48;
	КодЦифры9 = 57;              
	НомСимв = 1;
	
	
	Пока НомСимв <= СтрДлина(ИсходнаяСтрока) Цикл
		
		КодТекСимв = КодСимвола(ИсходнаяСтрока, НомСимв);
		КодСледСимв = КодСимвола(ИсходнаяСтрока, НомСимв + 1);
		
		Если (КодТекСимв >= КодЦифры0 И КодТекСимв <= КодЦифры9) И (КодСледСимв >= КодЦифры0 И КодСледСимв <= КодЦифры9) Тогда
			Результат.Добавить(Число(Сред(ИсходнаяСтрока, НомСимв, 2)) + 130);
			НомСимв = НомСимв + 1;
		ИначеЕсли КодТекСимв >= 128 Тогда
			Результат.Добавить(235);
			Результат.Добавить(КодТекСимв - 127);
		Иначе
			Результат.Добавить(КодТекСимв + 1);
		КонецЕсли;
		
		НомСимв = НомСимв + 1;
		
	КонецЦикла;
	
	Если РегистрыСведений.НастройкиПрограммы_ХамелеонЦРПТ.Получить().ДобавитьПрефиксДляGS1 Тогда
		Результат.Вставить(0, 232);
	КонецЕсли;
	
	
	Возврат Результат;
	
КонецФункции

Функция ДобавитьСлужебнуюИнформацию(Знач КодыСимволов)
	
	Для каждого Стр Из ТаблицаЗависимостей() Цикл
		Если КодыСимволов.Количество() <= Стр.КодовДанных Тогда
			ПараметрыКода = Стр;
			Прервать;
		КонецЕсли;
	КонецЦикла;
	
	Если ПараметрыКода.КодовДанных = КодыСимволов.Количество() Тогда
		Возврат КодыСимволов;
	КонецЕсли;
	
	КодыСимволов.Добавить(129);
	
	Для Сч = 1 По ПараметрыКода.КодовДанных - КодыСимволов.Количество() Цикл
		ПСЧ = ((149 * Сч) % 253) + 1;
		КодыСимволов.Добавить((ПСЧ + 129) % 254);
	КонецЦикла;
	
	Возврат КодыСимволов;
	
КонецФункции

Функция РазделитьИнформациюНаБлоки(БайтыСимволов)
	
	Блоки = Новый Массив;
	Если ПараметрыКода.ВсегоБлоков = 1 Тогда
		Блоки.Добавить(БайтыСимволов);
		Возврат Блоки;
	КонецЕсли;
	
	Для Сч = 1 По ПараметрыКода.ВсегоБлоков Цикл
		Блоки.Добавить(Новый Массив);
	КонецЦикла;
	
	ИндБайта = 0;
	Пока ИндБайта < ПараметрыКода.КодовДанных Цикл
		Для ИндБлока = 0 По ПараметрыКода.ВсегоБлоков - 1 Цикл
			Блоки[ИндБлока].Добавить(БайтыСимволов[ИндБайта]);
			ИндБайта = ИндБайта + 1;
		КонецЦикла;
	КонецЦикла;
	
	Возврат Блоки;
	
КонецФункции

Функция СоздатьБайтыКоррекции(Блоки)
		
	ВсегоБайтовКоррекции = ПараметрыКода.КодовКоррекции / ПараметрыКода.ВсегоБлоков;
	ГенМногочлен = ГенерирующийМногочлен(ВсегоБайтовКоррекции);
	ОбаПоляГалуа = ПоляГалуа();
	ПолеГалуа = ОбаПоляГалуа.ПрямоеПоле;
	ОбратноеПолеГалуа = ОбаПоляГалуа.ОбратноеПоле;
	Результат = Новый Массив;
	
	Для каждого Блок Из Блоки Цикл
		
		БайтыКоррекции = Новый Массив;
		Для каждого Байт Из Блок Цикл
			БайтыКоррекции.Добавить(Байт);
		КонецЦикла;
		Для Сч = 1 По ВсегоБайтовКоррекции - Блок.Количество() Цикл
			БайтыКоррекции.Добавить(0);
		КонецЦикла;
		
		Для Сч = 1 По Блок.Количество() Цикл
			
			ТекБайт = БайтыКоррекции[0];
			БайтыКоррекции.Удалить(0);
			БайтыКоррекции.Добавить(0);
			
			Если ТекБайт = 0 Тогда
				Продолжить;
			КонецЕсли;
			
			ТекБайт = ОбратноеПолеГалуа.Получить(ТекБайт);    
			
			Для Инд = 0 По ГенМногочлен.ВГраница() Цикл
				ТекЧлен = ОбратноеПолеГалуа.Получить(ГенМногочлен[Инд]);
				ТекЧлен = (ТекЧлен + ТекБайт) % 255;
				ТекЧлен = ПолеГалуа.Получить(ТекЧлен);
				БайтКор = БайтыКоррекции[Инд];
				Слагаемые = Мин(БайтКор, ТекЧлен) * 1000 + Макс(БайтКор, ТекЧлен);
				БайтыКоррекции[Инд] = ПобитИсклИли[Слагаемые];
			КонецЦикла;
			
		КонецЦикла;
		
		Результат.Добавить(БайтыКоррекции);
		
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

Функция ОбъединитьБлоки(БайтыСимволов, БайтыКоррекции)
	
	Результат = Новый Массив;
	Из10в2 = ПереводИз10в2();
	Для Инд = 0 По ПараметрыКода.ВсегоБлоков - 1 Цикл
		Для каждого Байт Из БайтыСимволов[Инд] Цикл
			Результат.Добавить(Из10в2[Байт]);	
		КонецЦикла; 	
		Для каждого Байт Из БайтыКоррекции[Инд] Цикл
			Результат.Добавить(Из10в2[Байт]);
		КонецЦикла;
	КонецЦикла;
	Возврат Результат
	
КонецФункции

Функция ТаблицаЗависимостей()
	
	Текст = ПолучитьМакет("РазмерыКодов");
	
	Результат = Новый ТаблицаЗначений;
	Для каждого ИмяКол Из СтрРазделить_1(Текст.ПолучитьСтроку(1), Символы.Таб) Цикл
		Результат.Колонки.Добавить(ИмяКол);
	КонецЦикла;
	
	Для НомСтр = 2 По Текст.КоличествоСтрок() Цикл
		НовСтр = Результат.Добавить();
		ТекСтр = Текст.ПолучитьСтроку(НомСтр);
		Колонки = СтрРазделить_1(ТекСтр, Символы.Таб, Ложь);
		Для НомКол = 0 По Колонки.ВГраница() Цикл
			НовСтр[НомКол] = Число(Колонки[НомКол]);
		КонецЦикла;
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

Функция ГенерирующийМногочлен(БайтовКоррекции)
	
	Текст = ПолучитьМакет("ГенерирующиеМногочлены");
	Для Ном = 1 По Текст.КоличествоСтрок() Цикл
		Многочлен = СтрРазделить_1(Текст.ПолучитьСтроку(Ном), Символы.Таб);
		Если Число(Многочлен[0]) = БайтовКоррекции Тогда
			Прервать;
		КонецЕсли;
	КонецЦикла;
	
	Результат = Новый Массив;
	Члены = СтрРазделить_1(Многочлен[1], " ");
	МаксИнд = Члены.ВГраница();
	Для Инд = 0 По МаксИнд Цикл
		Результат.Добавить(Число(Члены[МаксИнд - Инд]));
	КонецЦикла;
	Возврат Результат;	
	
	//Результат = Новый Массив;
	//Для Инд = 1 По Члены.ВГраница() Цикл
	//	Поз = СтрНайти(Члены[Инд], "x");
	//	Если Поз = 0 Тогда
	//		Коэф = Члены[Инд];
	//	ИначеЕсли Поз = 1 Тогда
	//		Коэф = "0";
	//	Иначе
	//		Коэф = Лев(Члены[Инд], Поз - 1);
	//	КонецЕсли;
	//	Результат.Вставить(Число(Коэф));
	//КонецЦикла;
	//Возврат Результат;
	
КонецФункции

Функция ПоляГалуа()
	
	ПрямоеПоле = Новый Соответствие;
	ОбратноеПоле = Новый Соответствие;	
	Текст = ПолучитьМакет("ПолеГалуа");
	Для НомСтр = 1 По Текст.КоличествоСтрок() Цикл
		ТекЧисло = Число(Текст.ПолучитьСтроку(НомСтр));
		ПрямоеПоле.Вставить(НомСтр - 1, ТекЧисло);
		ОбратноеПоле.Вставить(ТекЧисло, НомСтр - 1);
	КонецЦикла;
	
	Возврат Новый Структура("ПрямоеПоле,ОбратноеПоле", ПрямоеПоле, ОбратноеПоле);
	
КонецФункции

Функция ПереводИз10в2()
	
	Результат = Новый Соответствие;
	Результат.Вставить(0, "00000000");
	Для Сч = 1 По 255 Цикл
		Результат.Вставить(Сч, Из10в2(Сч, 8));
	КонецЦикла;
	Возврат Результат;
	
КонецФункции

Функция Из10в2(Число, Разрядность)
	
	Результат = Из10вЛюбую(Число, "01");
	Результат = Число(Результат);
	Возврат Формат(Результат, "ЧЦ=" + Разрядность + "; ЧВН=; ЧГ=");
	
КонецФункции

Функция Из10вЛюбую(Знач Значение, Шаблон)
	
    Результат = "";
    Основание = СтрДлина(Шаблон);
    Пока Значение > 0 цикл
        Остат = Значение % Основание;
        Результат1 = Сред(Шаблон, Остат + 1, 1);
        Значение = (Значение - Остат) / Основание;
        Результат = Результат1 + Результат;
    КонецЦикла;
    Возврат Результат;
	
КонецФункции

#КонецОбласти

#Область Низкоуровневое_кодирование

Функция РазместитьИнформацию(БайтыДанных)
	
	Областей = Sqrt(ПараметрыКода.ВсегоОбластей);
	РазмерХолста = ПараметрыКода.РазмерОбласти * Областей;
	Холст = Новый Массив(РазмерХолста, РазмерХолста);
	МаксМодуль = Холст.ВГраница();
	
	#Область ДобавлениеДанных
	
	Ряд = 4;
	Кол = 0;
	ТекБайт = 0;
	
	Пока Ряд < РазмерХолста Или Кол < РазмерХолста Цикл
		
		Если Ряд = РазмерХолста И Кол = 0 Тогда
			НарисоватьУгол1(Холст, БайтыДанных[ТекБайт]);
			ТекБайт = ТекБайт + 1;
		КонецЕсли;
		Если Ряд = РазмерХолста - 2 И Кол = 0 И РазмерХолста % 4 <> 0 Тогда
			НарисоватьУгол2(Холст, БайтыДанных[ТекБайт]);
			ТекБайт = ТекБайт + 1;
		КонецЕсли;
		Если Ряд = РазмерХолста - 2 И Кол = 0 И РазмерХолста % 8 = 4 Тогда
			НарисоватьУгол3(Холст, БайтыДанных[ТекБайт]);
			ТекБайт = ТекБайт + 1;
		КонецЕсли;
		Если Ряд = РазмерХолста + 4 И Кол = 2 И РазмерХолста % 8 = 0 Тогда
			НарисоватьУгол4(Холст, БайтыДанных[ТекБайт]);
			ТекБайт = ТекБайт + 1;
		КонецЕсли;
		
		Пока Ряд >= 0 И Кол < РазмерХолста Цикл
			Если Ряд < РазмерХолста И Кол >= 0 И Холст[Ряд][Кол] = Неопределено Тогда
				НарисоватьШтатЮта(Холст, Ряд, Кол, БайтыДанных[ТекБайт]);
				ТекБайт = ТекБайт + 1;
			КонецЕсли;
			Ряд = Ряд - 2;
			Кол = Кол + 2;
		КонецЦикла;
		
		Ряд = Ряд + 1;
		Кол = Кол + 3;
		
		Пока Ряд < РазмерХолста И Кол >= 0 Цикл
			Если Ряд >= 0 И Кол < РазмерХолста И Холст[Ряд][Кол] = Неопределено Тогда
				НарисоватьШтатЮта(Холст, Ряд, Кол, БайтыДанных[ТекБайт]);
				ТекБайт = ТекБайт + 1;
			КонецЕсли;
			Ряд = Ряд + 2;
			Кол = Кол - 2;
		КонецЦикла;
		
		Ряд = Ряд + 3;
		Кол = Кол + 1;
		
	КонецЦикла;
	
	Если Холст[МаксМодуль][МаксМодуль] = Неопределено Тогда
		Для Ряд = 0 По 1 Цикл
			Для Кол = 0 По 1 Цикл
				Холст[МаксМодуль - Ряд][МаксМодуль - Кол] = ?(Ряд = Кол, 1, 0);
			КонецЦикла;
		КонецЦикла;
	КонецЕсли;
	
	#КонецОбласти
	
	#Область ШаблонПоиска
			
	Цвет = 1;
	Для каждого Ряд Из Холст Цикл
		Для Сч = 1 По Областей Цикл
			Ряд.Вставить(ПараметрыКода.РазмерОбласти * (Областей - Сч + 1), Цвет);
			Ряд.Вставить(ПараметрыКода.РазмерОбласти * (Областей - Сч), 1);
		КонецЦикла;
		Цвет = 1 - Цвет;
	КонецЦикла;
	
	ГоризонтЛиния = Новый Массив;
	ГоризонтПунктир = Новый Массив;
	Для Сч = 1 По ПараметрыКода.РазмерКода Цикл
		ГоризонтЛиния.Добавить(1);
		ГоризонтПунктир.Добавить(Сч % 2);
	КонецЦикла;
	ГоризонтЛиния = Новый ФиксированныйМассив(ГоризонтЛиния);
	ГоризонтПунктир = Новый ФиксированныйМассив(ГоризонтПунктир);
	
	Для Сч = 1 По Областей Цикл
		Холст.Вставить(ПараметрыКода.РазмерОбласти * (Областей - Сч + 1), Новый Массив(ГоризонтЛиния));
		Холст.Вставить(ПараметрыКода.РазмерОбласти * (Областей - Сч), Новый Массив(ГоризонтПунктир));
	КонецЦикла;
	
	#КонецОбласти
	
	//Пометка как личная подпись
	Если Областей = 2 Тогда
		Середина = ПараметрыКода.РазмерКода / 2;
		Холст[Середина-1][Середина] = 0;
	КонецЕсли;
	
	#Область ДобавлениеОтступа
		
	Для каждого Ряд Из Холст Цикл
		Для Сч = 1 По ШиринаРамки Цикл
			Ряд.Вставить(0, 0);
			Ряд.Добавить(0);
		КонецЦикла;
	КонецЦикла;
	
	БелыйРяд = Новый Массив;
	Для Сч = 1 По ПараметрыКода.РазмерКода + ШиринаРамки * 2 Цикл
		БелыйРяд.Добавить(0);
	КонецЦикла;
	
	Для Сч = 1 По ШиринаРамки Цикл
		Холст.Вставить(0, БелыйРяд);
		Холст.Добавить(БелыйРяд);
	КонецЦикла;
	
	#КонецОбласти
	
	Возврат Холст;
	
КонецФункции	

Функция СоздатьКартинку(Холст)
	РазмерЭлемента=20;
	РазмерХолста = Холст.Количество();
	Высота = РазмерХолста * РазмерЭлемента;
	Ширина = РазмерХолста * РазмерЭлемента;
	
	// Для простоты формирования возьемём 24 бита. По 8 бит на каждый канал. Альфаканал не используем. 
	ГлубинаЦвета_ЦРПТ_ЦРПТ = 3; // Измеряется в байтах. 	
	
	// Каждая строка должна содержать количество байтов кратное 4.
	БайтовДополнение = (4 - ГлубинаЦвета_ЦРПТ_ЦРПТ * Ширина % 4) % 4; 
	
	РазмерФайла = ГлубинаЦвета_ЦРПТ_ЦРПТ * Ширина * Высота + Высота * БайтовДополнение;	
	
	///////////////////////////////////////////////////////////////////////////////
		
	ПотокТело = Новый ПотокВПамяти();
	ЗаписьДанных = Новый ЗаписьДанных(ПотокТело);
		
	//BITMAPFILEHEADER
	
	//bfType 
	ЗаписьДанных.ЗаписатьЦелое16(16973, ПорядокБайтов.BigEndian); // 0x424D big-endian = 0x4D42 little-endian. Признак формата. Всегда это значение.
	//bfSize
	ЗаписьДанных.ЗаписатьЦелое32(54 + РазмерФайла);
	//bfReserved1
	ЗаписьДанных.ЗаписатьЦелое16(0);	
	//bfReserved2
	ЗаписьДанных.ЗаписатьЦелое16(0);	
	//bfOffBits
	ЗаписьДанных.ЗаписатьЦелое32(54);
	
	//BITMAPINFOHEADER // версия 3
	// biSize
	ЗаписьДанных.ЗаписатьЦелое32(40); 
	// biWidth
	ЗаписьДанных.ЗаписатьЦелое32(Ширина);			// ширина изображения в пикселах 
	// biHeight
	ЗаписьДанных.ЗаписатьЦелое32(Высота);			// высота изображения в пикселах
	// biPlanes
	ЗаписьДанных.ЗаписатьЦелое16(1);				// содержит единицу
	// biBitCount
	ЗаписьДанных.ЗаписатьЦелое16(ГлубинаЦвета_ЦРПТ_ЦРПТ * 8);	// количество бит на пиксел 
	// biCompression
	ЗаписьДанных.ЗаписатьЦелое32(0);				// тип сжатия 
	// biSizeImage
	ЗаписьДанных.ЗаписатьЦелое32(РазмерФайла);		// размер изображения в байтах
	// biXPelsPerMeter
	ЗаписьДанных.ЗаписатьЦелое32(0);				// горизонтальное разрешение в пикселах на метр 
	// biYPelsPerMeter
	ЗаписьДанных.ЗаписатьЦелое32(0); 				// вертикальное разрешение в пикселах на метр 
	// biClrUsed
	ЗаписьДанных.ЗаписатьЦелое32(0);				//  количество используемых цветовых индексов в палитре 
	// biClrImportant
	ЗаписьДанных.ЗаписатьЦелое32(0);				// количество индексов
	
	///////////////////////////////////////////////////////////////////////////////
	
	БелаяПолоса = Новый БуферДвоичныхДанных(РазмерЭлемента * ГлубинаЦвета_ЦРПТ_ЦРПТ);
	ЧернаяПолоса = Новый БуферДвоичныхДанных(РазмерЭлемента * ГлубинаЦвета_ЦРПТ_ЦРПТ);
	
	Для Инд = 0 По БелаяПолоса.Размер - 1 Цикл
		БелаяПолоса.Установить(Инд, 255);
		ЧернаяПолоса.Установить(Инд, 0);
	КонецЦикла;
	
	МаксМодуль = РазмерХолста - 1;
	Для Выс = 0 По МаксМодуль Цикл	// строки снизу вверх		
		
		ВесьРяд = Новый БуферДвоичныхДанных(Ширина * ГлубинаЦвета_ЦРПТ_ЦРПТ + БайтовДополнение);
		
		Для Шир = 0 По МаксМодуль Цикл
			
			Значение = Холст[МаксМодуль - Выс][Шир];
			  			
			Если Значение = 0 Тогда
				ЗаписьДанных.ЗаписатьБуферДвоичныхДанных(БелаяПолоса);
				ВесьРяд.Записать(Шир * БелаяПолоса.Размер, БелаяПолоса);
			Иначе
				ЗаписьДанных.ЗаписатьБуферДвоичныхДанных(ЧернаяПолоса);
				ВесьРяд.Записать(Шир * ЧернаяПолоса.Размер, ЧернаяПолоса);
			КонецЕсли;
						
		КонецЦикла;
		
		// Забиваем нулями остаток строки. Так как размер строки должен быть кратен 4 байтам.
		Для Доп = 1 По БайтовДополнение Цикл		
			ЗаписьДанных.ЗаписатьБайт(0);
			ВесьРяд.Установить(ВесьРяд.Размер - Доп, 0);
		КонецЦикла;
		
		Для Сч = 1 По РазмерЭлемента - 1 Цикл
			ЗаписьДанных.ЗаписатьБуферДвоичныхДанных(ВесьРяд);
		КонецЦикла;
		
	КонецЦикла;
		
	ЗаписьДанных.Закрыть();	
	Возврат ПотокТело.ЗакрытьИПолучитьДвоичныеДанные();
		
КонецФункции

Процедура НарисоватьТочку(Холст, Знач Ряд, Знач Кол, Байт, Разряд)
	
	Если Ряд < 0 Тогда
		Ряд = Ряд + Холст.Количество();
		Кол = Кол + 4 - (Холст.Количество() + 4) % 8;
	КонецЕсли;
	
	Если Кол < 0 Тогда
		Кол = Кол + Холст.Количество();
		Ряд = Ряд + 4 - (Холст.Количество() + 4) % 8;
	КонецЕсли;
	
	Холст[Ряд][Кол] = Число(Сред(Байт, Разряд, 1));
	
КонецПроцедуры

Процедура НарисоватьШтатЮта(Холст, Ряд, Кол, Байт)
	
	НарисоватьТочку(Холст, Ряд - 2, Кол - 2, Байт, 1);
	НарисоватьТочку(Холст, Ряд - 2, Кол - 1, Байт, 2);
	НарисоватьТочку(Холст, Ряд - 1, Кол - 2, Байт, 3);
	НарисоватьТочку(Холст, Ряд - 1, Кол - 1, Байт, 4);
	НарисоватьТочку(Холст, Ряд - 1, Кол, 	 Байт, 5);
	НарисоватьТочку(Холст, Ряд, 	Кол - 2, Байт, 6);
	НарисоватьТочку(Холст, Ряд, 	Кол - 1, Байт, 7);
	НарисоватьТочку(Холст, Ряд, 	Кол, 	 Байт, 8);
	
КонецПроцедуры

Процедура НарисоватьУгол1(Холст, Байт)
	
	НарисоватьТочку(Холст, Холст.Количество() - 1, 0, Байт, 1);
	НарисоватьТочку(Холст, Холст.Количество() - 1, 1, Байт, 2);
	НарисоватьТочку(Холст, Холст.Количество() - 1, 2, Байт, 3);
	НарисоватьТочку(Холст, 0, Холст.Количество() - 2, Байт, 4);
	НарисоватьТочку(Холст, 0, Холст.Количество() - 1, Байт, 5);
	НарисоватьТочку(Холст, 1, Холст.Количество() - 1, Байт, 6);
	НарисоватьТочку(Холст, 2, Холст.Количество() - 1, Байт, 7);
	НарисоватьТочку(Холст, 3, Холст.Количество() - 1, Байт, 8);
	
КонецПроцедуры

Процедура НарисоватьУгол2 (Холст, Байт)
	
	НарисоватьТочку(Холст, Холст.Количество() - 3, 0, Байт, 1);
	НарисоватьТочку(Холст, Холст.Количество() - 2, 0, Байт, 2);
	НарисоватьТочку(Холст, Холст.Количество() - 1, 0, Байт, 3);
	НарисоватьТочку(Холст, 0, Холст.Количество() - 4, Байт, 4);
	НарисоватьТочку(Холст, 0, Холст.Количество() - 3, Байт, 5);
	НарисоватьТочку(Холст, 0, Холст.Количество() - 2, Байт, 6);
	НарисоватьТочку(Холст, 0, Холст.Количество() - 1, Байт, 7);
	НарисоватьТочку(Холст, 1, Холст.Количество() - 1, Байт, 8);
	
КонецПроцедуры

Процедура НарисоватьУгол3(Холст, Байт)
	
	НарисоватьТочку(Холст, Холст.Количество() - 3, 0, Байт, 1);
	НарисоватьТочку(Холст, Холст.Количество() - 2, 0, Байт, 2);
	НарисоватьТочку(Холст, Холст.Количество() - 1, 0, Байт, 3);
	НарисоватьТочку(Холст, 0, Холст.Количество() - 2, Байт, 4);
	НарисоватьТочку(Холст, 0, Холст.Количество() - 1, Байт, 5);
	НарисоватьТочку(Холст, 1, Холст.Количество() - 1, Байт, 6);
	НарисоватьТочку(Холст, 2, Холст.Количество() - 1, Байт, 7);
	НарисоватьТочку(Холст, 3, Холст.Количество() - 1, Байт, 8);
	
КонецПроцедуры

Процедура НарисоватьУгол4(Холст, Байт)
	
	НарисоватьТочку(Холст, Холст.Количество() - 1, 0, Байт, 1);
	НарисоватьТочку(Холст, Холст.Количество() - 1, Холст.Количество() - 1, Байт, 2);
	НарисоватьТочку(Холст, 0, Холст.Количество() - 3, Байт,3);
	НарисоватьТочку(Холст, 0, Холст.Количество() - 2, Байт,4);
	НарисоватьТочку(Холст, 0, Холст.Количество() - 1, Байт,5);
	НарисоватьТочку(Холст, 1, Холст.Количество() - 3, Байт,6);
	НарисоватьТочку(Холст, 1, Холст.Количество() - 2, Байт,7);
	НарисоватьТочку(Холст, 1, Холст.Количество() - 1, Байт,8);
	
КонецПроцедуры

#КонецОбласти

Функция СтрРазделить_1(Знач Значение, Знач Разделитель = ",", Знач ВключатьПустые = Истина) Экспорт
	
	Результат = Новый Массив;
	
	Позиция = Найти(Значение, Разделитель);
	Пока Позиция > 0 Цикл
		Подстрока = Лев(Значение, Позиция - 1);
		Если ВключатьПустые Или Не ПустаяСтрока(Подстрока) Тогда
			Результат.Добавить(Подстрока);
		КонецЕсли;
		Значение = Сред(Значение, Позиция + СтрДлина(Разделитель));
		Позиция = Найти(Значение, Разделитель);
	КонецЦикла;
	
	Если ВключатьПустые Или Не ПустаяСтрока(Значение) Тогда
		Результат.Добавить(Значение);
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

Функция Сгенерировать128(Знач ИсходнаяСтрока) Экспорт
	Если РегистрыСведений.НастройкиПрограммы_ХамелеонЦРПТ.Получить().ДобавитьДваНуля Тогда
		ИсходнаяСтрока="00"+ИсходнаяСтрока;
	//	ИсходнаяСтрока=Символ(232)+ИсходнаяСтрока;
//		ИсходнаяСтрока=РаскодироватьСтроку("%1D",СпособКодированияСтроки.КодировкаURL)+ИсходнаяСтрока;
	//	ИсходнаяСтрока=РаскодироватьСтроку("%E8",СпособКодированияСтроки.КодировкаURL)+РаскодироватьСтроку("%1D",СпособКодированияСтроки.КодировкаURL)+ИсходнаяСтрока;
	КонецЕсли;
	Если РегистрыСведений.НастройкиПрограммы_ХамелеонЦРПТ.Получить().ДобавитьFNCПриПечатиУпаковок Тогда
		//Возврат СгенерироватьGS128("00"+ИсходнаяСтрока)
		Возврат СгенерироватьGS128(ИсходнаяСтрока)
	КонецЕсли;
	
	КодированнаяСтрока = ЗакодироватьДанные128(ИсходнаяСтрока);
	Холст = РазместитьИнформацию128(КодированнаяСтрока);
	Возврат СоздатьКартинку128(Холст);
		
КонецФункции

Функция ЗакодироватьДанные128(Знач ИсходнаяСтрока)
	
	Коды = Новый Массив(108);
	Стр = 
	"212222,222122,222221,121223,121322,131222,122213,122312," + 
	"132212,221213,221312,231212,112232,122132,122231,113222," + 
	"123122,123221,223211,221132,221231,213212,223112,312131," + 
	"311222,321122,321221,312212,322112,322211,212123,212321," + 
	"232121,111323,131123,131321,112313,132113,132311,211313," + 
	"231113,231311,112133,112331,132131,113123,113321,133121," + 
	"313121,211331,231131,213113,213311,213131,311123,311321," + 
	"331121,312113,312311,332111,314111,221411,431111,111224," + 
	"111422,121124,121421,141122,141221,112214,112412,122114," + 
	"122411,142112,142211,241211,221114,413111,241112,134111," + 
	"111242,121142,121241,114212,124112,124211,411212,421112," + 
	"421211,212141,214121,412121,111143,111341,131141,114113," + 
	"114311,411113,411311,113141,114131,311141,411131,211412," + 
	"211214,211232,2331112,";

	Ном = 1;
	Пока Найти(Стр, ",") > 0 Цикл
		Поз = Найти(Стр, ",");
		Код = Лев(Стр, Поз - 1);
		Стр = Сред(Стр, Поз + 1);
		Коды[Ном] = Код;
		Ном = Ном + 1;
	КонецЦикла;
	
	Результат = "";
	
	bCode = "";
	curMode = символ(0);
	Ном = 1;
	Пока Ном <= СтрДлина(ИсходнаяСтрока) Цикл
		КодСимв = КодСимвола(Сред(ИсходнаяСтрока, Ном, 1));
		Ном = Ном + 1;
		Если КодСимв > 127 Тогда
			Возврат "";
		КонецЕсли;
		Если Ном <= СтрДлина(ИсходнаяСтрока) Тогда
			КодСимв2 = КодСимвола(Сред(ИсходнаяСтрока, Ном, 1));
		Иначе
			КодСимв2 = 0;
		КонецЕсли;
		Если (КодСимв >= 48) and ((КодСимв <= 57)) and (КодСимв2 >= 48) and (КодСимв2 <= 57) Тогда 
			Ном = Ном + 1;
			Если bCode = "" Тогда 
				curMode = "C";
				bCode = bCode + "i" //#$69; //"i" CODE - C
			ИначеЕсли curMode <> "C" Тогда 
				curMode = "C";
				bCode = bCode + "c"; //#$63; //"c"
			КонецЕсли;
			bCode = bCode + Символ((КодСимв - 48) * 10 + (КодСимв2 - 48));
		Иначе
			Если bCode = "" Тогда 
				Если КодСимв < 32 Тогда  //" "
					curMode = "A";
					bCode = bCode + "g"; //#$67; //"g" CODE - A
				Иначе
					curMode = "B";
					bCode = bCode + "h"; //#$68; //"h" CODE - B
				КонецЕсли;
			КонецЕсли;
			Если (КодСимв < 32) and  (curMode <> "A") Тогда 
				curMode = "A";
				bCode = bCode + "e"; //#$65; //"e"
			ИначеЕсли ((КодСимв >= 64) and (curMode <> "B")) Или (curMode = "C") Тогда 
				curMode = "B";
				bCode = bCode + "d"; //#$64; //"d"
			КонецЕсли;
			Если (КодСимв < 32) Тогда 
				bCode = bCode + Символ(КодСимв + 64); //"@"
			Иначе
				bCode = bCode + Символ(КодСимв - 32); //" "
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	Если bCode <> "" Тогда
		cCode = КодСимвола(bCode); // - цел(КодСимв(bCode)/103)  //"g"
	Иначе
		cCode = 0;
	КонецЕсли;
	Для Сч = 1 По СтрДлина(bCode) - 1 Цикл
		cCode = (cCode + КодСимвола(Сред(bCode, Сч + 1, 1)) * Сч); //mod $67;
	КонецЦикла;
	cCode = cCode - Цел(cCode/103) * 103;
	bCode = bCode + Символ(cCode) + "j"; //#$6a; //"j" CODE - @
	Для Сч = 1 По СтрДлина(bCode) Цикл 
      Результат = Результат + (Коды[КодСимвола(Сред(bCode, Сч, 1)) + 1]);
    КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

Функция РазместитьИнформацию128(КодированнаяСтрока)
	ШиринаРамки=1;
	
	
	ТекЦвет = 1;
	Результат = Новый Массив;
	Для Сч = 1 По ШиринаРамки Цикл
		Результат.Добавить(0);
	КонецЦикла;
	Для Симв = 1 По СтрДлина(КодированнаяСтрока) Цикл
		Для Сч = 1 По Число(Сред(КодированнаяСтрока, Симв, 1)) Цикл
			Результат.Добавить(ТекЦвет);
		КонецЦикла;
		ТекЦвет = 1 - ТекЦвет;
	КонецЦикла;
	Для Сч = 1 По ШиринаРамки Цикл
		Результат.Добавить(0);
	КонецЦикла;
	Возврат Результат;
	
КонецФункции

Функция СоздатьКартинку128(Холст)
	 ВысотаКартинки=	60;
	 РазмерЭлемента=1;
	РазмерХолста = Холст.Количество();
	Высота = ВысотаКартинки;
	Ширина = РазмерХолста * РазмерЭлемента;
	
	// Для простоты формирования возьемём 24 бита. По 8 бит на каждый канал. Альфаканал не используем. 
	ГлубинаЦвета_ЦРПТ = 3; // Измеряется в байтах. 	
	
	// Каждая строка должна содержать количество байтов кратное 4.
	БайтовДополнение = (4 - ГлубинаЦвета_ЦРПТ * Ширина % 4) % 4; 
	
	РазмерФайла = ГлубинаЦвета_ЦРПТ * Ширина * Высота + Высота * БайтовДополнение;	
	
	///////////////////////////////////////////////////////////////////////////////
		
	ПотокТело = Новый ПотокВПамяти();
	ЗаписьДанных = Новый ЗаписьДанных(ПотокТело);
		
	//BITMAPFILEHEADER
	
	//bfType 
	ЗаписьДанных.ЗаписатьЦелое16(16973, ПорядокБайтов.BigEndian); // 0x424D big-endian = 0x4D42 little-endian. Признак формата. Всегда это значение.
	//bfSize
	ЗаписьДанных.ЗаписатьЦелое32(54 + РазмерФайла);
	//bfReserved1
	ЗаписьДанных.ЗаписатьЦелое16(0);	
	//bfReserved2
	ЗаписьДанных.ЗаписатьЦелое16(0);	
	//bfOffBits
	ЗаписьДанных.ЗаписатьЦелое32(54);
	
	//BITMAPINFOHEADER // версия 3
	// biSize
	ЗаписьДанных.ЗаписатьЦелое32(40); 
	// biWidth
	ЗаписьДанных.ЗаписатьЦелое32(Ширина);			// ширина изображения в пикселах 
	// biHeight
	ЗаписьДанных.ЗаписатьЦелое32(Высота);			// высота изображения в пикселах
	// biPlanes
	ЗаписьДанных.ЗаписатьЦелое16(1);				// содержит единицу
	// biBitCount
	ЗаписьДанных.ЗаписатьЦелое16(ГлубинаЦвета_ЦРПТ * 8);	// количество бит на пиксел 
	// biCompression
	ЗаписьДанных.ЗаписатьЦелое32(0);				// тип сжатия 
	// biSizeImage
	ЗаписьДанных.ЗаписатьЦелое32(РазмерФайла);		// размер изображения в байтах
	// biXPelsPerMeter
	ЗаписьДанных.ЗаписатьЦелое32(0);				// горизонтальное разрешение в пикселах на метр 
	// biYPelsPerMeter
	ЗаписьДанных.ЗаписатьЦелое32(0); 				// вертикальное разрешение в пикселах на метр 
	// biClrUsed
	ЗаписьДанных.ЗаписатьЦелое32(0);				//  количество используемых цветовых индексов в палитре 
	// biClrImportant
	ЗаписьДанных.ЗаписатьЦелое32(0);				// количество индексов
	
	///////////////////////////////////////////////////////////////////////////////
	
	БелаяПолоса = Новый БуферДвоичныхДанных(РазмерЭлемента * ГлубинаЦвета_ЦРПТ);
	ЧернаяПолоса = Новый БуферДвоичныхДанных(РазмерЭлемента * ГлубинаЦвета_ЦРПТ);
	
	Для Инд = 0 По БелаяПолоса.Размер - 1 Цикл
		БелаяПолоса.Установить(Инд, 255);
		ЧернаяПолоса.Установить(Инд, 0);
	КонецЦикла;
	
	МаксМодуль = РазмерХолста - 1;
	
	ВесьРяд = Новый БуферДвоичныхДанных(Ширина * ГлубинаЦвета_ЦРПТ + БайтовДополнение);
	
	Для Шир = 0 По МаксМодуль Цикл
		
		Значение = Холст[Шир];
		
		Если Значение = 0 Тогда
			ВесьРяд.Записать(Шир * БелаяПолоса.Размер, БелаяПолоса);
		Иначе
			ВесьРяд.Записать(Шир * ЧернаяПолоса.Размер, ЧернаяПолоса);
		КонецЕсли;
		
	КонецЦикла;
	
	// Забиваем нулями остаток строки. Так как размер строки должен быть кратен 4 байтам.
	Для Доп = 1 По БайтовДополнение Цикл		
		ВесьРяд.Установить(ВесьРяд.Размер - Доп, 0);
	КонецЦикла;
	
	Для Сч = 1 По Высота Цикл
		ЗаписьДанных.ЗаписатьБуферДвоичныхДанных(ВесьРяд);
	КонецЦикла;
	
	ЗаписьДанных.Закрыть();	
	Возврат ПотокТело.ЗакрытьИПолучитьДвоичныеДанные();
		
КонецФункции
		

Функция СгенерироватьGS128(ИсходнаяСтрока) Экспорт
	
	КодированнаяСтрока = ЗакодироватьДанныеGS128(ИсходнаяСтрока);
	Холст = РазместитьИнформациюGS128(КодированнаяСтрока);
	Возврат СоздатьКартинкуGS128(Холст);
		
КонецФункции

Функция ЗакодироватьДанныеGS128(Знач ИсходнаяСтрока)
	
	Коды = Новый Массив(108);
	Стр = 
	"212222,222122,222221,121223,121322,131222,122213,122312," + 
	"132212,221213,221312,231212,112232,122132,122231,113222," + 
	"123122,123221,223211,221132,221231,213212,223112,312131," + 
	"311222,321122,321221,312212,322112,322211,212123,212321," + 
	"232121,111323,131123,131321,112313,132113,132311,211313," + 
	"231113,231311,112133,112331,132131,113123,113321,133121," + 
	"313121,211331,231131,213113,213311,213131,311123,311321," + 
	"331121,312113,312311,332111,314111,221411,431111,111224," + 
	"111422,121124,121421,141122,141221,112214,112412,122114," + 
	"122411,142112,142211,241211,221114,413111,241112,134111," + 
	"111242,121142,121241,114212,124112,124211,411212,421112," + 
	"421211,212141,214121,412121,111143,111341,131141,114113," + 
	"114311,411113,411311,113141,114131,311141,411131,211412," + 
	"211214,211232,2331112,";

	Ном = 1;
	Пока Найти(Стр, ",") > 0 Цикл
		Поз = Найти(Стр, ",");
		Код = Лев(Стр, Поз - 1);
		Стр = Сред(Стр, Поз + 1);
		Коды[Ном] = Код;
		Ном = Ном + 1;
	КонецЦикла;
	
	Результат = "";
	
	Если Лев(ИсходнаяСтрока, 2) = "\F" Тогда
		ИсходнаяСтрока = Сред(ИсходнаяСтрока, 3); 
	КонецЕсли;
	ИсходнаяСтрока = Символ(134) + ИсходнаяСтрока;
	ИсходнаяСтрока = СтрЗаменить(ИсходнаяСтрока, "\F", Символ(29));
	
	bCode = "";
	curMode = символ(0);
	Ном = 1;
	Пока Ном <= СтрДлина(ИсходнаяСтрока) Цикл 
		КодСимв = КодСимвола(Сред(ИсходнаяСтрока, Ном, 1));
		Ном = Ном + 1;
		Если КодСимв > 127 Тогда
			//Возврат "";
		КонецЕсли;
		Если Ном <= СтрДлина(ИсходнаяСтрока) Тогда
			КодСимв2 = КодСимвола(Сред(ИсходнаяСтрока, Ном, 1));
		Иначе
			КодСимв2 = 0;
		КонецЕсли;
		Если (КодСимв >= 48) and ((КодСимв <= 57)) and (КодСимв2 >= 48) and (КодСимв2 <= 57) Тогда 
			Ном = Ном + 1;
			Если bCode = "" Тогда 
				curMode = "C";
				bCode = bCode + "i" //#$69; //"i" CODE - C
			ИначеЕсли curMode <> "C" Тогда 
				curMode = "C";
				bCode = bCode + "c"; //#$63; //"c"
			КонецЕсли;
			bCode = bCode + Символ((КодСимв - 48) * 10 + (КодСимв2 - 48));
		Иначе
			Если bCode = "" Тогда 
				Если КодСимв < 32 Тогда  //" "
					curMode = "A";
					bCode = bCode + "g"; //#$67; //"g" CODE - A
				Иначе
					curMode = "B";
					bCode = bCode + "h"; //#$68; //"h" CODE - B
				КонецЕсли;
			КонецЕсли;
			Если (КодСимв < 32) and  (curMode <> "A") Тогда 
				curMode = "A";
				bCode = bCode + "e"; //#$65; //"e"
			ИначеЕсли ((КодСимв >= 64) and (curMode <> "B")) Или (curMode = "C") Тогда 
				curMode = "B";
				bCode = bCode + "d"; //#$64; //"d"
			КонецЕсли;
			Если (КодСимв < 32) Тогда 
				bCode = bCode + Символ(КодСимв + 64); //"@"
			Иначе
				bCode = bCode + Символ(КодСимв - 32); //" "
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	Если bCode <> "" Тогда
		cCode = КодСимвола(bCode); // - цел(КодСимв(bCode)/103)  //"g"
	Иначе
		cCode = 0;
	КонецЕсли;
	Для Сч = 1 По СтрДлина(bCode) - 1 Цикл
		cCode = (cCode + КодСимвола(Сред(bCode, Сч + 1, 1)) * Сч); //mod $67;
	КонецЦикла;               
	cCode = cCode - Цел(cCode/103) * 103;
	bCode = bCode + Символ(cCode) + "j"; //#$6a; //"j" CODE - @
	Для Сч = 1 По СтрДлина(bCode) Цикл 
      Результат = Результат + (Коды[КодСимвола(Сред(bCode, Сч, 1)) + 1]);
    КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

Функция РазместитьИнформациюGS128(КодированнаяСтрока)
	
	ТекЦвет = 1;
	Результат = Новый Массив;
	Для Сч = 1 По ШиринаРамки Цикл
		Результат.Добавить(0);
	КонецЦикла;
	Для Симв = 1 По СтрДлина(КодированнаяСтрока) Цикл
		Для Сч = 1 По Число(Сред(КодированнаяСтрока, Симв, 1)) Цикл
			Результат.Добавить(ТекЦвет);
		КонецЦикла;
		ТекЦвет = 1 - ТекЦвет;
	КонецЦикла;
	Для Сч = 1 По ШиринаРамки Цикл
		Результат.Добавить(0);
	КонецЦикла;
	Возврат Результат;
	
КонецФункции

Функция СоздатьКартинкуGS128(Холст)
	 ВысотаКартинки=	100;
	 РазмерЭлемента=2;
	
	РазмерХолста = Холст.Количество();
	Высота = ВысотаКартинки;
	Ширина = РазмерХолста * РазмерЭлемента;
	
	// Для простоты формирования возьемём 24 бита. По 8 бит на каждый канал. Альфаканал не используем. 
	ГлубинаЦветаКартинки = 3; // Измеряется в байтах. 	
	
	// Каждая строка должна содержать количество байтов кратное 4.
	БайтовДополнение = (4 - ГлубинаЦветаКартинки * Ширина % 4) % 4; 
	
	РазмерФайла = ГлубинаЦветаКартинки * Ширина * Высота + Высота * БайтовДополнение;	
	
	///////////////////////////////////////////////////////////////////////////////
		
	ПотокТело = Новый ПотокВПамяти();
	ЗаписьДанных = Новый ЗаписьДанных(ПотокТело);
		
	//BITMAPFILEHEADER
	
	//bfType 
	ЗаписьДанных.ЗаписатьЦелое16(16973, ПорядокБайтов.BigEndian); // 0x424D big-endian = 0x4D42 little-endian. Признак формата. Всегда это значение.
	//bfSize
	ЗаписьДанных.ЗаписатьЦелое32(54 + РазмерФайла);
	//bfReserved1
	ЗаписьДанных.ЗаписатьЦелое16(0);	
	//bfReserved2
	ЗаписьДанных.ЗаписатьЦелое16(0);	
	//bfOffBits
	ЗаписьДанных.ЗаписатьЦелое32(54);
	
	//BITMAPINFOHEADER // версия 3
	// biSize
	ЗаписьДанных.ЗаписатьЦелое32(40); 
	// biWidth
	ЗаписьДанных.ЗаписатьЦелое32(Ширина);			// ширина изображения в пикселах 
	// biHeight
	ЗаписьДанных.ЗаписатьЦелое32(Высота);			// высота изображения в пикселах
	// biPlanes
	ЗаписьДанных.ЗаписатьЦелое16(1);				// содержит единицу
	// biBitCount
	ЗаписьДанных.ЗаписатьЦелое16(ГлубинаЦветаКартинки * 8);	// количество бит на пиксел 
	// biCompression
	ЗаписьДанных.ЗаписатьЦелое32(0);				// тип сжатия 
	// biSizeImage
	ЗаписьДанных.ЗаписатьЦелое32(РазмерФайла);		// размер изображения в байтах
	// biXPelsPerMeter
	ЗаписьДанных.ЗаписатьЦелое32(0);				// горизонтальное разрешение в пикселах на метр 
	// biYPelsPerMeter
	ЗаписьДанных.ЗаписатьЦелое32(0); 				// вертикальное разрешение в пикселах на метр 
	// biClrUsed
	ЗаписьДанных.ЗаписатьЦелое32(0);				//  количество используемых цветовых индексов в палитре 
	// biClrImportant
	ЗаписьДанных.ЗаписатьЦелое32(0);				// количество индексов
	
	///////////////////////////////////////////////////////////////////////////////
	
	БелаяПолоса = Новый БуферДвоичныхДанных(РазмерЭлемента * ГлубинаЦветаКартинки);
	ЧернаяПолоса = Новый БуферДвоичныхДанных(РазмерЭлемента * ГлубинаЦветаКартинки);
	
	Для Инд = 0 По БелаяПолоса.Размер - 1 Цикл
		БелаяПолоса.Установить(Инд, 255);
		ЧернаяПолоса.Установить(Инд, 0);
	КонецЦикла;
	
	МаксМодуль = РазмерХолста - 1;
	
	ВесьРяд = Новый БуферДвоичныхДанных(Ширина * ГлубинаЦветаКартинки + БайтовДополнение);
	
	Для Шир = 0 По МаксМодуль Цикл
		
		Значение = Холст[Шир];
		
		Если Значение = 0 Тогда
			ВесьРяд.Записать(Шир * БелаяПолоса.Размер, БелаяПолоса);
		Иначе
			ВесьРяд.Записать(Шир * ЧернаяПолоса.Размер, ЧернаяПолоса);
		КонецЕсли;
		
	КонецЦикла;
	
	// Забиваем нулями остаток строки. Так как размер строки должен быть кратен 4 байтам.
	Для Доп = 1 По БайтовДополнение Цикл		
		ВесьРяд.Установить(ВесьРяд.Размер - Доп, 0);
	КонецЦикла;
	
	Для Сч = 1 По Высота Цикл
		ЗаписьДанных.ЗаписатьБуферДвоичныхДанных(ВесьРяд);
	КонецЦикла;
	
	ЗаписьДанных.Закрыть();	
	Возврат ПотокТело.ЗакрытьИПолучитьДвоичныеДанные();
		
КонецФункции
